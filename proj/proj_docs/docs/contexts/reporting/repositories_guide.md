# repositories_guide.md

Brief: Complete repository specification for Reporting context. ReportRepository for report metadata CRUD, query optimization with select_related, filtering by session/user/date, and update operations for export details. Focus on access control queries and cross-context data collection.

---

## Repository Layer Purpose

**Why Repositories Matter**:
- **Data access abstraction**: Isolate Django ORM from business logic
- **Query optimization**: Use select_related to reduce database hits
- **Access control queries**: Filter by ownership (lecturer vs admin)
- **Cross-context integration**: Collect data from multiple contexts
- **Testability**: Mock repositories for service testing

**Priority: CRITICAL** - Gateway to all data

---

# REPORTREPOSITORY

## Overview

**File**: `repositories/report_repository.py`

**Purpose**: CRUD operations and queries for Report model, export updates

**Dependencies**:
- Report model
- Session model (cross-context)
- User model (cross-context)

**Priority: CRITICAL** - All report data access

---

## Method Categories

1. **CRUD Operations**: Create, get by ID, update export details
2. **Query Methods**: By session, by user, by date range, all reports
3. **Authorization Helpers**: Filter by ownership (lecturer-specific)
4. **Update Methods**: Add export metadata to existing report

---

# PART 1: CRUD OPERATIONS

## create(data: dict) → Report

**Purpose**: Create new report metadata record

**Parameters**:
```python
data = {
    "session_id": 456,
    "generated_by": 10,
    # generated_date auto-set
    # file_path NULL by default
    # file_type NULL by default
}
```

**Returns**: Created Report instance

**Why Important**: Every report generation starts here

**Priority: CRITICAL**

**Validation** (before calling):
- session_id exists (foreign key validation)
- generated_by exists (foreign key validation)
- User authorized to generate report for session

**Error Handling**:
- IntegrityError (FK violation) → Map to `SessionNotFoundError` or `UserNotFoundError`

---

## get_by_id(report_id: int) → Report | None

**Purpose**: Retrieve report by primary key

**Returns**: 
- Report instance if found
- None if not found

**Query Optimization**:
```python
select_related('session', 'generated_by')
```

**Why select_related**: 
- Avoids N+1 queries when accessing session or user details
- Single JOIN query instead of multiple SELECT

**Use Case**: View report details (need session name, user name)

**Priority: HIGH**

---

## update_export_details(report_id: int, file_path: str, file_type: str) → Report

**Purpose**: Update report with export file information

**Parameters**:
- report_id: Report to update
- file_path: Absolute or relative path to exported file
- file_type: "csv" or "excel"

**Returns**: Updated Report instance

**Why Important**: Links physical file to report metadata

**Priority: HIGH**

**Atomicity**: Both fields updated together (CHECK constraint enforced)

**Validation**:
- Report exists
- file_path and file_type currently NULL (prevent re-export to different format)
- file_type in ["csv", "excel"]

**Error Handling**:
- Report not found → Raise `ReportNotFoundError`
- Already exported → Raise `ReportAlreadyExportedError`
- CHECK constraint violation → Database error (shouldn't happen if validated)

---

# PART 2: QUERY METHODS

## get_by_session(session_id: int) → QuerySet[Report]

**Purpose**: Get all reports for a specific session

**Returns**: QuerySet of Report instances (ordered by generated_date descending)

**Query Optimization**:
```python
select_related('generated_by')
order_by('-generated_date')
```

**Why Important**: 
- Lecturer views report history for session
- Admin monitors session reporting activity

**Use Case**: "View all reports generated for Session 456"

**Priority: HIGH**

**Result**: Newest reports first (historical timeline)

---

## get_by_user(user_id: int) → QuerySet[Report]

**Purpose**: Get all reports generated by specific user

**Returns**: QuerySet of Report instances (ordered by generated_date descending)

**Query Optimization**:
```python
filter(generated_by=user_id)
select_related('session')
order_by('-generated_date')
```

**Why Important**: User dashboard showing their report history

**Use Case**: "Show all reports I've generated"

**Priority: HIGH**

---

## get_by_session_and_user(session_id: int, user_id: int) → QuerySet[Report]

**Purpose**: Get reports for session generated by specific user

**Returns**: QuerySet of Report instances

**Why Important**: **Access control** - lecturer can only see own reports for session

**Use Case**: "Show reports I generated for this session"

**Priority: CRITICAL** - Authorization boundary

**Query**:
```python
filter(session_id=session_id, generated_by=user_id)
order_by('-generated_date')
```

---

## get_by_date_range(start_date: datetime, end_date: datetime) → QuerySet[Report]

**Purpose**: Get reports generated within date range

**Parameters**:
- start_date: Inclusive start (e.g., "2025-10-01T00:00:00Z")
- end_date: Inclusive end (e.g., "2025-10-31T23:59:59Z")

**Returns**: QuerySet of Report instances

**Query**:
```python
filter(generated_date__gte=start_date, generated_date__lte=end_date)
order_by('-generated_date')
```

**Why Important**: Admin monitoring, cleanup of old reports

**Use Case**: "Show all reports from October 2025"

**Priority: MEDIUM**

---

## get_exported_reports() → QuerySet[Report]

**Purpose**: Get all reports that have been exported (file_path NOT NULL)

**Returns**: QuerySet of Report instances

**Query**:
```python
filter(file_path__isnull=False)
select_related('session', 'generated_by')
order_by('-generated_date')
```

**Why Important**: 
- File cleanup operations
- Storage monitoring
- Export analytics

**Use Case**: "Show all reports with files (for cleanup)"

**Priority: MEDIUM**

---

## get_view_only_reports() → QuerySet[Report]

**Purpose**: Get all reports that were viewed but not exported (file_path NULL)

**Returns**: QuerySet of Report instances

**Query**:
```python
filter(file_path__isnull=True)
select_related('session', 'generated_by')
order_by('-generated_date')
```

**Why Important**: Analytics - how many reports viewed vs exported

**Use Case**: "Show view-only reports (no files)"

**Priority: LOW**

---

## get_all_reports_for_lecturer(lecturer_id: int) → QuerySet[Report]

**Purpose**: Get all reports for sessions owned by lecturer

**Returns**: QuerySet of Report instances

**Query Logic**:
```python
# Get sessions where lecturer is owner
lecturer_sessions = Session.objects.filter(lecturer_id=lecturer_id)

# Get reports for those sessions
reports = Report.objects.filter(session__in=lecturer_sessions)
                        .select_related('session', 'generated_by')
                        .order_by('-generated_date')
```

**Why Important**: **Access control** - lecturer sees reports for own sessions only

**Priority: CRITICAL** - Authorization boundary

**Note**: Includes reports generated by other users (e.g., admin) for lecturer's sessions

---

## get_all_reports() → QuerySet[Report]

**Purpose**: Get all reports (admin only)

**Returns**: QuerySet of Report instances

**Query Optimization**:
```python
select_related('session', 'generated_by')
order_by('-generated_date')
```

**Why Important**: Admin monitoring, global report analytics

**Use Case**: Admin dashboard

**Priority: MEDIUM**

**Authorization**: Should only be called for admin users

---

# PART 3: CROSS-CONTEXT DATA COLLECTION

## get_session_details(session_id: int) → dict

**Purpose**: Collect session data from Session Management context

**Returns**: Dictionary with session details:
```python
{
    "session_id": 456,
    "course_name": "Data Structures",
    "course_code": "CSC201",
    "program_name": "Computer Science",
    "program_code": "BCS",
    "stream_name": "Stream A",  # or None
    "time_created": "2025-10-19T08:00:00Z",
    "time_ended": "2025-10-19T10:00:00Z",
    "lecturer_name": "Dr. Jane Smith",
    "latitude": "-1.28333412",
    "longitude": "36.81666588"
}
```

**Query**:
```python
session = Session.objects.select_related(
    'course', 'program', 'stream', 'lecturer__user'
).get(pk=session_id)
```

**Why Important**: Report header information

**Priority: CRITICAL** - Core report data

**Error Handling**: Session not found → Raise `SessionNotFoundError`

---

## get_eligible_students(session_id: int) → QuerySet[StudentProfile]

**Purpose**: Get all students eligible for session (by program/stream)

**Logic**:
1. Get session program and stream
2. Query StudentProfile:
   - If session has stream: `program=session.program AND stream=session.stream`
   - If session has no stream: `program=session.program`

**Returns**: QuerySet of StudentProfile instances

**Query Optimization**:
```python
select_related('user', 'program', 'stream')
```

**Why Important**: Determines "Absent" students (eligible but no attendance)

**Priority: CRITICAL** - Report completeness

**Cross-Context**: User Management context provides StudentProfile

---

## get_attendance_for_session(session_id: int) → QuerySet[Attendance]

**Purpose**: Get all attendance records for session

**Returns**: QuerySet of Attendance instances

**Query Optimization**:
```python
filter(session_id=session_id)
select_related('student_profile__user')
```

**Why Important**: Returns raw attendance records for the session. The repository provides the raw data; the service layer (AttendanceAggregator) is responsible for applying the official Present/Absent rules (attendance timestamp within the session time window AND `is_within_radius == True`) when deciding which records count as Present for the report.

**Priority: CRITICAL** - Core attendance data

**Cross-Context**: Attendance Recording context provides Attendance records

---

## get_attendance_statistics(session_id: int) → dict

**Purpose**: Calculate attendance summary statistics using the official Present/Absent policy

**Returns**: Dictionary with counts and percentages:
```python
{
    "total_students": 50,
    "present_count": 35,
    "absent_count": 15,
    "present_percentage": 70.0,
    "absent_percentage": 30.0,
    "within_radius_count": 40,        # diagnostic
    "outside_radius_count": 3        # diagnostic
}
```

**Logic**:
1. Get eligible students count (total)
2. Compute `present_count` by counting distinct eligible students who have at least one attendance record for the session that satisfies BOTH:
   - attendance timestamp is within the session's scheduled start and end times, and
   - `is_within_radius` is True

   Example Django ORM sketch (assumes session_start/session_end are available):
   ```python
   present_qs = (
       Attendance.objects
       .filter(session_id=session_id,
               is_within_radius=True,
               timestamp__gte=session_start,
               timestamp__lte=session_end)
       .values('student_profile_id')
       .distinct()
   )
   present_count = present_qs.count()
   ```

3. Calculate absent: `absent_count = total - present_count` (official absent count uses the strict present_count above)
4. Calculate percentages (guard against division by zero)
5. Optionally compute diagnostic aggregations:
   - `within_radius_count`: count of attendance records for session with `is_within_radius=True` (regardless of timestamp)
   - `outside_radius_count`: count of attendance records with `is_within_radius=False`

   These diagnostics are useful for troubleshooting (e.g., many outside-radius hits), but do not change the official Present/Absent counts.

**Why Important**: Report summary header. Ensure `present_count` follows the official policy (in-time and in-radius) so reported percentages and counts match institutional rules.

**Priority: HIGH**

**Performance**: Use Django aggregation (`Count()`), `.values(...).distinct()` and appropriate indexes for efficiency

---

# PART 4: AUTHORIZATION HELPERS

## can_user_access_report(user_id: int, report_id: int) → bool

**Purpose**: Check if user can access specific report

**Authorization Logic**:
1. Get report with session relationship
2. If user is admin: return True
3. If user is lecturer:
   - Check if session.lecturer_id == user_id
   - Return True if match, False otherwise
4. If user is student: return False

**Returns**: Boolean

**Why Important**: **Access control** - prevent unauthorized report access

**Priority: CRITICAL** - Security boundary

**Use Case**: Middleware check before showing report details

---

## can_user_generate_report_for_session(user_id: int, session_id: int) → bool

**Purpose**: Check if user can generate report for session

**Authorization Logic**:
1. Get session
2. If user is admin: return True
3. If user is lecturer:
   - Check if session.lecturer_id == user_id
   - Return True if match, False otherwise
4. If user is student: return False

**Returns**: Boolean

**Why Important**: Prevent unauthorized report generation

**Priority: CRITICAL** - Security boundary

**Use Case**: API endpoint permission check

---

# PART 5: ERROR HANDLING

## Domain Exceptions

**File**: `exceptions.py`

```python
class ReportingError(Exception):
    """Base exception"""
    pass

class ReportNotFoundError(ReportingError):
    """Report doesn't exist"""
    pass

class SessionNotFoundError(ReportingError):
    """Session doesn't exist"""
    pass

class UserNotFoundError(ReportingError):
    """User doesn't exist"""
    pass

class ReportAlreadyExportedError(ReportingError):
    """Report already has export file"""
    pass

class UnauthorizedReportAccessError(ReportingError):
    """User cannot access this report"""
    pass
```

**Repository Error Mapping**:
- Django `ObjectDoesNotExist` → `ReportNotFoundError`, `SessionNotFoundError`, etc.
- Django `IntegrityError` (FK violation) → Context-specific error
- Database errors → Let propagate (infrastructure concern)

---

## File Organization

**Priority: MEDIUM** - Maintainability

```
reporting/
├── repositories/
│   ├── __init__.py
│   └── report_repository.py         # ReportRepository class
│       ├── CRUD operations
│       ├── Query methods
│       ├── Cross-context data collection
│       └── Authorization helpers
│
├── exceptions.py                     # Domain exceptions
│
└── tests/
    └── test_repositories.py          # Repository tests
```

**Why Single Repository**: 
- Only one entity (Report)
- Cross-context queries organized within same file
- Clear separation of concerns (CRUD vs queries vs authorization)

---

## Query Optimization Strategies

### Use select_related for Foreign Keys

**Why**: Reduce N+1 query problem

**Example**:
```python
# Bad (N+1 queries)
reports = Report.objects.filter(session_id=456)
for report in reports:
    print(report.generated_by.username)  # Additional query per iteration

# Good (1 query with JOIN)
reports = Report.objects.filter(session_id=456).select_related('generated_by')
for report in reports:
    print(report.generated_by.username)  # No additional queries
```

**Priority: HIGH** - Performance critical

---

### Use prefetch_related for Many-to-Many (Not Applicable)

**Note**: Report has no many-to-many relationships, so `prefetch_related` not needed

---

### Index Usage

**Ensure queries use indexes**:
- `filter(session_id=X)` → Uses `idx_reports_session_id`
- `filter(generated_by=Y)` → Uses `idx_reports_generated_by`
- `order_by('-generated_date')` → Uses `idx_reports_generated_date`

**Priority: HIGH** - Query performance

---

## Repository Summary

**ReportRepository Methods**:

**CRUD**:
- `create` - Create report metadata
- `get_by_id` - Retrieve by PK
- `update_export_details` - Add file path/type

**Queries**:
- `get_by_session` - Reports for session
- `get_by_user` - Reports by user
- `get_by_session_and_user` - Combined filter
- `get_by_date_range` - Date filtering
- `get_exported_reports` - File exports only
- `get_view_only_reports` - No files
- `get_all_reports_for_lecturer` - Lecturer's sessions
- `get_all_reports` - Admin view

**Cross-Context**:
- `get_session_details` - Session data
- `get_eligible_students` - Program/stream students
- `get_attendance_for_session` - Attendance records
- `get_attendance_statistics` - Summary stats

**Authorization**:
- `can_user_access_report` - Access check
- `can_user_generate_report_for_session` - Generation check

---

## Key Takeaways

1. **Query optimization** - select_related for FK joins
2. **Cross-context integration** - Collect data from Session, User, Attendance contexts
3. **Authorization helpers** - Lecturer vs admin access control
4. **Update operations** - Export details set once (immutability)
5. **Error mapping** - Django exceptions to domain exceptions
6. **Statistics calculation** - Aggregate queries for summary
7. **Filtering flexibility** - By session, user, date, export status

---

**Status**: 📋 Complete repository specification ready for implementation

**Priority Methods**:
- CRITICAL: create, get_by_id, get_session_details, get_eligible_students, authorization helpers
- HIGH: get_by_session, get_by_user, update_export_details, get_attendance_for_session
- MEDIUM: get_by_date_range, get_exported_reports, statistics